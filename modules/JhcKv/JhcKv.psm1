#
# Module file for module 'JhcKv'
#
# Generated by: john cravever
#
$Global:JhcKvManifest = "$env:APPDATA\jkman.json"
$Global:jsonDepth = 100
$Global:encoding = 'ascii'
$Script:subIndex = 2 
$Script:rgIndex = 4
$Script:rsIndex = -1
function getManifest {
    $obj
    if(Test-Path -Path $Global:JhcKvManifest) {
        
        $obj = Get-Content -Path $Global:JhcKvManifest | ConvertFrom-Json
    }
    else {
        Write-Warning -Message "No Key Vault manifest found..."
    }        
    
    return $obj
}

function Get-DefinedVault {
    
    $obj = getManifest
    $a
    if(-not $?) {
        $Error[0]
    }
    $a = $obj.ResourceId -split '/'
    $rt = "$($a[$Script:subIndex]),$($a[$Script:rgIndex]),$($a[$Script:rsIndex])" | ConvertFrom-Csv -Header 'Subscription', 'ResourceGroupName', 'KeyVaultName'

    return $rt
}

function Write-Manifest {
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [Microsoft.Azure.Commands.ResourceManager.Cmdlets.SdkModels.PSResource]
        $keyVaultResourceObj
    )

    begin{}
    process{
        $keyVaultResourceObj | ConvertTo-Json -Depth $Global:jsonDepth | Out-File -FilePath $Global:JhcKvManifest -Encoding $Global:encoding -Verbose
    }
    end{}
}

function processSecTag {
    param (
        [Parameter(Mandatory)]
        [System.Object]
        $secObj
    )

    $r

    if($secObj.Tags.info) {
        $r = $secObj.Tags.info | ConvertFrom-Json
    }
    else {
        $r = "," | ConvertFrom-Csv -Header 'ComputerName', 'UserName', 'Notes'
    }
    return $r
}

function Get-SecretList {
    [OutputType('JhcKv.SecretList')]
    [CmdletBinding()]
    param ()  #--This is needed or else OutputType wont map back to the types.ps1xml

    class SecretList {
        [System.String]$Name
        [System.String]$ContentType
        [System.String]$Created
        [System.String]$Updated
        [System.String]$ComputerName
        [System.String]$UserName
        [System.String]$Notes
    }
    
    $obj = getManifest
    $seclst 
    
    $seclst = Get-AzKeyVaultSecret -ResourceId $obj.ResourceId
    if(-not $?) {
        return $null
    }
    $tg

    foreach($s in $seclst) {
        $tg = processSecTag -secObj $s
        $o = New-Object -TypeName SecretList
        $o.Name = $s.Name
        $o.ContentType = $s.ContentType
        $o.Created = $s.Created
        $o.Updated = $s.Updated
        $o.ComputerName = $tg.computername
        $o.UserName = $tg.username
        $o.Notes = $tg.notes
        $o
    }
}

function Get-SecretValue {
    param (
        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName=$true)]
        [System.String]
        $Name   
    )
    begin {
        $sec
        $obj = getManifest
    }
    process {
        $sec = Get-AzKeyVaultSecret -ResourceId $obj.ResourceId -Name $Name
    }
    end {
        $sec | Select-Object -Property Name, Created, Updated, SecretValue
    }
}

function Add-Secret {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,
        [Parameter(Mandatory = $false)]
        [System.String]
        $UserName,
        [Parameter(Mandatory = $false)]
        [System.String]
        $ComputerName,
        [Parameter(Mandatory = $false)]
        [System.String]
        $Notes,
        [Parameter(Mandatory = $false)]
        [System.String]
        $ContentType = 'txt',
        [Parameter(Mandatory = $true)]
        [System.Security.SecureString]
        $SecretValue
    )

    $info = ''
    $header = 'UserName','ComputerName','Notes'
    $tagVal = '' 

    if($UserName) {
        $info += $UserName
    }
    $info += ','
    if($ComputerName) {
        $info += $ComputerName
    }
    $info += ','
    if($Notes){
        $info += $Notes
    }
    
    $tagVal =  $info | ConvertFrom-Csv -Header $header | ConvertTo-Json -Compress
    
    while($SecretValue.Length -eq 0){
        Write-Warning -Message "SecretValue is empty."
        $SecretValue = Read-Host -Prompt 'SecretValue' -AsSecureString
    }

    $obj = getManifest
    if(Get-AzKeyVaultSecret -ResourceId $obj.ResourceId -Name $Name) {
        Write-Error -Message "Secret: $Name already exists."
        return $null
    }

    $rt = Set-AzKeyVaultSecret -VaultName $obj.Name -Name $Name -SecretValue $SecretValue -ContentType $ContentType -Tag @{'info' = $tagVal}
    if(-not $?){
        return $null
    }

    return $rt | Select-Object -Property Name, Created
}

function Update-Secret {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [System.String]
        $Name,
        [Parameter(Mandatory = $true)]
        [System.Security.SecureString]
        $SecretValue
    )

    while($SecretValue.Length -eq 0){
        Write-Warning -Message "SecretValue is empty."
        $SecretValue = Read-Host -Prompt 'SecretValue' -AsSecureString
    }

    $obj = getManifest
    if(-not (Get-AzKeyVaultSecret -ResourceId $obj.ResourceId -Name $Name)) {
        Write-Error -Message "Secret: $Name doesn't exist."
        return $null
    }

    $rt = Set-AzKeyVaultSecret -VaultName $obj.Name -Name $Name -SecretValue $SecretValue
    if(-not $?){
        return $null
    }

    return $rt | Select-Object -Property Name, Updated
}
